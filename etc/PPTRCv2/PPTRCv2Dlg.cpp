// PPTRCv2Dlg.cpp : implementation file
//

#include "stdafx.h"
#include "PPTRCv2.h"
#include "PPTRCv2Dlg.h"
#include "protocol.h"
#include "winable.h"


#ifdef _DEBUG
#define new DEBUm_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//--------------------------------------------------------------------------------
// Constants.
#define HIDE_TIMER    2002 
#define POLL_TIMER    2003 
#define LISTEN_PORT   1234
#define PPC_PORT     23523

#define FILE_MARK_DIR      '?'
#define FILE_MARK_CDROM    '<'
#define FILE_MARK_FLOPPY   '>'
#define FILE_MARK_HD       '|'

const char* g_szHome= "D:";

//--------------------------------------------------------------------------------
// CPPTRCv2Dlg dialog
IMPLEMENT_DYNAMIC(CPPTRCv2Dlg, CDialog)
CPPTRCv2Dlg::CPPTRCv2Dlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPPTRCv2Dlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPPTRCv2Dlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
  
  m_iWidth          = 220;         // width of BMP
  m_iHeight         = 165;         // height of BMP
  m_pResp           = NULL;        // response to client
  m_dwRespLen       = 0;           // length of response         
  m_pConnectionPoint= NULL;
  m_appPPT          = NULL;
  m_bOK             = FALSE;
  EnableAutomation();
}

void CPPTRCv2Dlg::OnFinalRelease()
{
	// When the last reference for an Automation object is released,
	// OnFinalRelease is called. The base class automatically
	// deletes the object. Add additional cleanup required for your
	// object before you call the base class.
	CCmdTarget::OnFinalRelease();
}

void CPPTRCv2Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPPTRCv2Dlg)
	DDX_Control(pDX, IDC_LISTBOX, m_ListBox);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPPTRCv2Dlg, CDialog)
	//{{AFX_MSm_MAP(CPPTRCv2Dlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()
	ON_WM_TIMER()
	//}}AFX_MSm_MAP
END_MESSAGE_MAP()


BEGIN_DISPATCH_MAP(CPPTRCv2Dlg, CCmdTarget)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "WindowSelectionChange", 2001, WindowSelectionChange,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "WindowBeforeRightClick", 2002 , WindowBeforeRightClick, VT_EMPTY , VTS_DISPATCH VTS_BOOL)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "WindowBeforeDoubleClick", 2003 , WindowBeforeDoubleClick, VT_EMPTY, VTS_DISPATCH VTS_BOOL)
	DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationClose", 2004, PresentationClose,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationSave", 2005, PresentationSave,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationOpen", 2006, PresentationOpen,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "NewPresentation", 2007, NewPresentation,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationNewSlide", 2008, PresentationNewSlide,VT_EMPTY, VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "WindowActivate", 2009, WindowActivate,VT_EMPTY, VTS_DISPATCH VTS_DISPATCH)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "WindowDeactivate", 2010, WindowDeactivate,VT_EMPTY, VTS_DISPATCH VTS_DISPATCH)
	DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideShowBegin", 2011, SlideShowBegin,VT_EMPTY, VTS_DISPATCH )
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideShowNextBuild", 2012, SlideShowNextBuild,VT_EMPTY, VTS_DISPATCH )
	DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideShowNextSlide", 2013, SlideShowNextSlide,VT_EMPTY, VTS_DISPATCH )
	DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideShowEnd", 2014, SlideShowEnd,VT_EMPTY, VTS_DISPATCH )
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationPrint", 2015, PresentationPrint,VT_EMPTY, VTS_DISPATCH )
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideSelectionChanged", 2016, SlideSelectionChanged,VT_EMPTY, VTS_DISPATCH )
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "ColorSchemeChanged", 2017, ColorSchemeChanged,VT_EMPTY, VTS_DISPATCH )
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "PresentationBeforeSave", 2018, PresentationBeforeSave,VT_EMPTY, VTS_DISPATCH VTS_BOOL)
	//DISP_FUNCTION_ID(CPPTRCv2Dlg, "SlideShowNextClick", 2019, SlideShowNextClick,VT_EMPTY, VTS_DISPATCH VTS_DISPATCH)	
END_DISPATCH_MAP()

//The GUUID is different from the one originally generated by Class Wizard. This GUUID is the same as the one for the EApplication outgoing event interface.
static const IID IID_IMyPPTEventsHandler= {0x914934C2,0x5A91,0x11CF, {0x87,0x00,0x00,0xAA,0x00,0x60,0x26,0x3b}};


BEGIN_INTERFACE_MAP(CPPTRCv2Dlg, CCmdTarget)
	INTERFACE_PART(CPPTRCv2Dlg, IID_IMyPPTEventsHandler, Dispatch)
END_INTERFACE_MAP()


// CPPTRCv2Dlg message handlers.

/*void CPPTRCv2Dlg::WindowSelectionChange(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "WindowSelectionChange");
}

void CPPTRCv2Dlg::WindowBeforeRightClick(LPDISPATCH Pres, VARIANT_BOOL* Cancel)
{
  m_pListBox->InsertString(-1, "WindowBeforeRightClick");
}

void CPPTRCv2Dlg::WindowBeforeDoubleClick(LPDISPATCH Pres, VARIANT_BOOL* Cancel)
{
	m_pListBox->InsertString(-1, "WindowBeforeDoubleClick");
}
*/

//--------------------------------------------------------------------------------
void CPPTRCv2Dlg::PresentationClose(LPDISPATCH Pres)
{
	m_ListBox.InsertString(-1, "PresentationClose");
}

/*
void CPPTRCv2Dlg::PresentationSave(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "PresentationSave");
}

void CPPTRCv2Dlg::PresentationOpen(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "PresentationOpen");
}

void CPPTRCv2Dlg::NewPresentation(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "NewPresentation");
}

void CPPTRCv2Dlg::PresentationNewSlide(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "PresentationNewSlide");
}

void CPPTRCv2Dlg::WindowActivate(LPDISPATCH Pres,LPDISPATCH Wn)
{
	m_pListBox->InsertString(-1, "WindowActivate");
}

void CPPTRCv2Dlg::WindowDeactivate(LPDISPATCH Pres, LPDISPATCH Wn)
{
	m_pListBox->InsertString(-1, "WindowDeactivate");
}
*/

//--------------------------------------------------------------------------------
void CPPTRCv2Dlg::SlideShowBegin(LPDISPATCH Wn)
{
  LPDISPATCH lpDispatch;
  SlideShowWindow ssWindow1;

  m_ListBox.InsertString(-1, "slideshow starts");

	// get the IDispatch of the SlideShowWindow object
  Wn->QueryInterface(IID_IDispatch, (void**)&lpDispatch);
  ssWindow1.AttachDispatch(lpDispatch);
     
	/*
  ssWindow1.SetHeight(310);
	ssWindow1.SetWidth(410);
	ssWindow1.SetTop(10);
  ssWindow1.SetLeft(10);
  */
}

/*
void CPPTRCv2Dlg::SlideShowNextBuild(LPDISPATCH Wn)
{
	m_pListBox->InsertString(-1, "SlideShowNextBuild");
}
*/

//--------------------------------------------------------------------------------
void CPPTRCv2Dlg::SlideShowNextSlide(LPDISPATCH Wn)
{
  LPDISPATCH lpDispatch;
  SlideShowWindow ssWindow;
  SlideShowView ssView;
  char szResp[4];    

  // ACK_NFO response
  // 4 bytes: index of current slide
	// get the IDispatch of the SlideShowWindow object
  Wn->QueryInterface(IID_IDispatch, (void**)&lpDispatch);
  ssWindow.AttachDispatch(lpDispatch);
  ssView= ssWindow.GetView();
  memset(szResp, 0, 4);
  itoa(ssView.GetCurrentShowPosition(), szResp, 10); 
  PrepareResponse(ACK_NFO, szResp, 4);
  SendResponse();
  ssView.ReleaseDispatch();
  ssWindow.ReleaseDispatch();
  lpDispatch->Release();
	m_ListBox.InsertString(-1, "slide change");
}

//--------------------------------------------------------------------------------
void CPPTRCv2Dlg::SlideShowEnd(LPDISPATCH Pres)
{
	m_ListBox.InsertString(-1, "slideshow ends");
}

/*
void CPPTRCv2Dlg::PresentationPrint(LPDISPATCH Pres)
{
	m_pListBox->InsertString(-1, "PresentationPrint");
}

// the following events are not available for PowerPoint 2000.
void CPPTRCv2Dlg::SlideSelectionChanged(LPDISPATCH SldRange)
{
	m_pListBox->InsertString(-1, "SlideSelectionChanged");
}

void CPPTRCv2Dlg::ColorSchemeChanged(LPDISPATCH SldRange)
{
	m_pListBox->InsertString(-1, "ColorSchemeChanged");
}

void CPPTRCv2Dlg::PresentationBeforeSave(LPDISPATCH Pres, VARIANT_BOOL *Cancel)
{
	m_pListBox->InsertString(-1, "PresentationBeforeSave");
}

void CPPTRCv2Dlg::SlideShowNextClick(LPDISPATCH Wn, LPDISPATCH nEffect)
{
	m_pListBox->InsertString(-1, "SlideShowNextClick");
}
*/

//--------------------------------------------------------------------------------
// CPPTRCv2Dlg message handlers
BOOL CPPTRCv2Dlg::OnInitDialog()
{
  sockaddr_in addr;

	CDialog::OnInitDialog();

  LPITEMIDLIST pidl;
  char buff[MAX_PATH];
  SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidl);  
  SHGetPathFromIDList(pidl, buff);

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
  
  // get path were preview pictures are stored
  GetCurrentDirectory(MAX_PATH, m_szImagePath);
  
  // init network address and create socket
  memset(&addr, 0, sizeof(sockaddr_in));
  addr.sin_family= AF_INET;
  addr.sin_port= htons(LISTEN_PORT);
  addr.sin_addr.s_addr= INADDR_ANY;
  
  m_sockListen= socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
  if (m_sockListen == INVALID_SOCKET) {
    AfxMessageBox("socket failed!");
    return(FALSE);
  }

  if (bind(m_sockListen, (sockaddr*)&addr, sizeof(sockaddr)) == SOCKET_ERROR) {
    AfxMessageBox("bind failed!");
    return(FALSE);
  }
  if (listen(m_sockListen, SOMAXCONN) == SOCKET_ERROR) {
    AfxMessageBox("listen failed!");
    return(FALSE);
  }

  SetTimer(POLL_TIMER, 10, NULL);
  m_szCurrPath[0]= 0;

  CoInitialize(NULL);

  return(TRUE);  // return TRUE  unless you set the focus to a control
}

//--------------------------------------------------------------------------------
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
void CPPTRCv2Dlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

//--------------------------------------------------------------------------------
// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
HCURSOR CPPTRCv2Dlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

//--------------------------------------------------------------------------------
// Timer event was triggered. 
BOOL CPPTRCv2Dlg::SendResponse()
{
  int iSent;
  int iSize= sizeof(sockaddr_in);
  sockaddr_in addr;
  SOCKET sock;

  sock= socket(AF_INET, SOCK_STREAM, 0);
  memcpy(&addr, &m_addrClient, iSize);
  addr.sin_port= htons(PPC_PORT);
  if (connect(sock, (sockaddr*)&addr, iSize) == SOCKET_ERROR) {
    return(FALSE);
  }
  
  iSent= send(sock, m_pResp, m_dwRespLen, 0);
  TRACE("sent: cmd: %c, bytes: %d\n", m_pResp[4], iSent);
  closesocket(sock);

  return(TRUE);
}

//--------------------------------------------------------------------------------
// Timer event was triggered. 
void CPPTRCv2Dlg::OnTimer(UINT nIDEvent) 
{
  if (nIDEvent == HIDE_TIMER) {
    HidePointer();
  
  } else {
    SOCKET sockConnect;
    char szBuff[1024];
    int iSize= sizeof(sockaddr);
    int iRet;
    TIMEVAL tv={0, 0};
  	fd_set readfds;
		
	  FD_ZERO(&readfds);
	  FD_SET(m_sockListen,&readfds);	
	
	  iRet= select(0, &readfds, NULL, NULL, &tv);
  
    if (iRet > 0) {
      try {
        sockConnect= accept(m_sockListen, (sockaddr*)&m_addrClient, &iSize);
        if (sockConnect == INVALID_SOCKET) {
          // listening socket was closed
          TRACE("*** LISTEN SOCKET CLOSED! ***\n");
          return;
        }
        TRACE("*** CONNECTION ESTABLISHED! ***\n");
        // read from client
        memset(szBuff, 0, 1024);
        iRet= recv(sockConnect, szBuff, 1024, 0);
        if (iRet != SOCKET_ERROR) {
          // prepare additional data
          TRACE("RECV: %s\n", &szBuff[4]);
          OnReceive(szBuff[4], &szBuff[5]);    
          closesocket(sockConnect);
      
          // release memory      
          if (m_pResp) {
            GlobalFree(m_pResp); 
            m_pResp= NULL;
            m_dwRespLen= 0;
          }
        }

      } catch(...) {
        TRACE("*** EXCEPTION CAUGHT ***\n");
        closesocket(sockConnect);
      } 
    }
  }
}

//--------------------------------------------------------------------------------
void CPPTRCv2Dlg::OnClose() 
{
  KillTimer(POLL_TIMER);

  try {
    // close sockets
    closesocket(m_sockListen);
  } catch (...) {    
  }
  WSACleanup();

	CDialog::OnClose();
}

//--------------------------------------------------------------------------------
BOOL CPPTRCv2Dlg::EstabConn()
{
  static const GUID IID_IEApplication= {0x914934C2,0x5A91,0x11CF, {0x87,0x00,0x00,0xAA,0x00,0x60,0x26,0x3b}};
  HRESULT hr;
  LPUNKNOWN pUnk;

  // get server's (PPT) IConnectionPointContainer interface.
  IConnectionPointContainer *pConnPtContainer;
  hr= m_appPPT.m_lpDispatch->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPtContainer);
  if (FAILED(hr)) {
    AfxMessageBox("Couldn't get IConnectionPointContainer interface.");
    return(FALSE);
  }
  
  // find connection point for events we're interested in.
  hr= pConnPtContainer->FindConnectionPoint(IID_IEApplication, &m_pConnectionPoint);	
  if(FAILED(hr)) {
    AfxMessageBox("Couldn't find connection point via event GUID.");
    return(FALSE);
  }
  
  // get the IUnknown interface of our event implementation.
  pUnk= NULL;
  pUnk = GetInterface(&IID_IUnknown);
  if (!pUnk) return(FALSE);

  // setup advisory connection!
  hr= m_pConnectionPoint->Advise(pUnk, &m_dwCookie);  
  if (FAILED(hr)) return(FALSE);  

  // release IConnectionPointContainer interface.
  pConnPtContainer->Release();
  
  m_bOK= TRUE;
  return(TRUE);
}

//--------------------------------------------------------------------------------
BOOL CPPTRCv2Dlg::Unregister()
{
  // use the cookie to unregister the sink.
  m_pConnectionPoint->Unadvise(m_dwCookie);
	m_pConnectionPoint->Release();  
  m_dwCookie= 0;

  return(TRUE);
}

//--------------------------------------------------------------------------------
// Creates the response string for the client. 
// If parameter "length" has default value -1, data is treated as 0-terminated string.
void CPPTRCv2Dlg::PrepareResponse(char cmd, const char *data, DWORD len /* = -1 */)
{  
  // message length supplied?
  if (len == -1) len= strlen(data) + 1;  // null termination for strings
  m_dwRespLen= len + 5;  // + 1 byte protocol command
                         // + 4 byte length field for response message

  m_pResp= (char*)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, m_dwRespLen);
  
  // bytes 0 ... 3: length field
  int i= 3;
  while(len) {
    m_pResp[i--]= (unsigned char)(len & 0x000000FF);
    len>>= 8;
  }
  
  // byte 4: protocol command
  m_pResp[4]= cmd;

  // bytes 5 ... m_dwRespLen - 1: payload
  memcpy(&m_pResp[5], data, m_dwRespLen - 5);
}


//--------------------------------------------------------------------------------
// Creates a preview of next Powerpoint slides in presentation. 
void CPPTRCv2Dlg::CreatePreview(long index)
{
  Slides slides;
  _Slide slide;
  COleVariant vaIndex(index, VT_I4);
  char szFullPath[MAX_PATH];
  char szBuff[256];
  HANDLE hFile;
  DWORD dwSize;
  DWORD dwBytesRead= 0;
  char *pszData;
  BOOL bOK;

  strcpy(szFullPath, m_szImagePath);
  sprintf(szBuff, "\\Slide%d", index);
  strcat(szFullPath, szBuff);
  strcat(szFullPath, ".BMP");
  
  // export current slide
  slides= m_pres.GetSlides();
  slide= slides.Item(vaIndex);
  slide.Export(szFullPath, "BMP", m_iWidth, m_iHeight);
  
  hFile= CreateFile(szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL); 
  if (hFile == INVALID_HANDLE_VALUE) {
    PrepareResponse(ERR, "Creating preview failed!");
    return;
  }
  dwSize= GetFileSize(hFile, NULL) + 4;

  // allocate memory for reading the file
  pszData= (char*)malloc(dwSize);
  
  // read the bitmap file
  bOK= ReadFile(hFile, (LPVOID)&pszData[4], dwSize, &dwBytesRead, NULL);
  if ((!bOK)||(dwBytesRead != dwSize - 4)) {
    PrepareResponse(ERR, "Creating preview failed!");
    CloseHandle(hFile);
    return;
  }
  memcpy(pszData, &index, 4);

  // response consists of protocol command + 4 bytes slide number + preview data
  PrepareResponse(ACK_PREV, pszData, 1 + dwSize);
  CloseHandle(hFile);
  free(pszData); 
}


//--------------------------------------------------------------------------------
// Determines, wether there is an open slideshow or not. 
BOOL CPPTRCv2Dlg::OpenSlideShowExists()
{
  if (m_view.m_lpDispatch != NULL) {
    try {      
      m_view.GetSlideShowName();
    } catch(COleDispatchException *e) {
      TRACE("*** SLIDESHOWVIEW WAS CLOSED ***\n");
      m_view.ReleaseDispatch();
      e->Delete();
    }
  }  
  return(m_view.m_lpDispatch != NULL);
}

//--------------------------------------------------------------------------------
// Closes currently active presentation 
//  1: Everything worked fine.
//  0: No slide show was open.
int CPPTRCv2Dlg::CloseSlideShow()
{
  if (OpenSlideShowExists()) {
    if (m_view.m_lpDispatch != NULL) {
      m_view.Exit();
      m_view.ReleaseDispatch();
    }
    try {
      m_pres.Close();
      m_pres.ReleaseDispatch();    
    } catch (CException *e) {
      m_pres.ReleaseDispatch();    
      e->Delete();
    }
    return(1);
  } else  
    return(0);
}

//--------------------------------------------------------------------------------
// Performs check on wether Powerpoint is running 
BOOL CPPTRCv2Dlg::IsPPTRunning() {
  if (m_appPPT.m_lpDispatch != NULL) {
    try {    
      if (!m_appPPT.GetVisible()) {
        // still running but invisible
        m_appPPT.SetVisible(1);
      }    
      return(TRUE);
    } catch(...) {
      // Powerpoint is no longer running, but dispatch still considered valid
      m_appPPT.ReleaseDispatch();
    }
  } 
  return(FALSE);
}


//--------------------------------------------------------------------------------
// Starts Powerpoint Application and stores _Application objet in "m_appPPT".
// Possible return codes are:
//  1: Everything worked fine.
//  0: Powerpoint was already running.
// -1: Something went wrong. Powerpoint is not running. 
int CPPTRCv2Dlg::RunPPT()
{ 
  if (IsPPTRunning()) {
    return(0);
  
  } else {  
    m_bOK= FALSE;
    COleException e;
    // start Powerpoint
    if(!m_appPPT.CreateDispatch("Powerpoint.Application", &e)) {
      CString str;
      str.Format("CreateDispatch() failed w/err 0x%08lx", e.m_sc),
      AfxMessageBox(str, MB_SETFOREGROUND);
      return(-1);  
    } else {
      //make it visible.
      m_appPPT.SetVisible(TRUE); 
      m_appPPT.SetDisplayAlerts(1);
      if (!EstabConn()) return(-1);
      return(1);
    }
  }
}

//--------------------------------------------------------------------------------
int CPPTRCv2Dlg::ClosePPT()
{
  if (IsPPTRunning()) {
    if (OpenSlideShowExists()) CloseSlideShow();
    if (m_bOK) Unregister();	
    m_appPPT.Quit();
    m_appPPT.ReleaseDispatch();
    return(1);
  } else
    return(0);
}

//--------------------------------------------------------------------------------
// Returns to running slideshow (displays it again if hidden by other window).
// Possible returns codes are:
//  1: Everything worked fine.
//  0: File could not be found/opened.
BOOL CPPTRCv2Dlg::ReturnToSlideShow()
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {
    long nr= m_view.GetCurrentShowPosition();
    m_view.GotoSlide(nr, 0);

    // ACK_NFO response
    Slides slides= m_pres.GetSlides();
    char resp[8];
    // 4 bytes: number of slides, 4 bytes: number of slides
    memset(&resp[0], 0, 8);
    itoa(slides.GetCount(), &resp[0], 10); 
    itoa(m_view.GetCurrentShowPosition(), &resp[4], 10);
    PrepareResponse(ACK_NFO, resp, 8);
    return(TRUE);    
  } else
    return(FALSE);
}

//--------------------------------------------------------------------------------
// Starts a slideshow with previously defined settings.
void CPPTRCv2Dlg::RunSlideShow()
{
  SlideShowSettings settings;
  SlideShowWindow ssWindow;
  
  settings= m_pres.GetSlideShowSettings();
  COleDispatchDriver lpDispatch= settings.Run();  
  ssWindow= m_pres.GetSlideShowWindow();
  m_view= ssWindow.GetView();
  ssWindow.ReleaseDispatch();
  settings.ReleaseDispatch();  
}

//--------------------------------------------------------------------------------
// Opens a specified slideshow in presentation mode.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: File could not be found/opened.
int CPPTRCv2Dlg::OpenSlideShow(char *file)
{
  Presentations presentations;
  SlideShowSettings settings;
  Slides slides;
  long lSlideCount;
  char szResp[4];

  // safety check
  if (!IsPPTRunning()) RunPPT();
  
  // close other slideshow if open
  if (OpenSlideShowExists()) CloseSlideShow();

  presentations= m_appPPT.GetPresentations();
  try {
    m_pres= presentations.Open(file, TRUE, TRUE, TRUE);
  } catch(...) {
    // file could not be found/opened!
    ClosePPT();
    return(0);
  }
  settings= m_pres.GetSlideShowSettings();
  settings.SetShowWithAnimation(TRUE);
  settings.SetLoopUntilStopped(TRUE);
  settings.SetAdvanceMode(1);  // 1: ppSlideShowManualAdvance
  RunSlideShow();  
  
  // prepare response for client (number of slides)
  slides= m_pres.GetSlides();
  lSlideCount= slides.GetCount();
  slides.ReleaseDispatch();
  
  // 4 bytes: number of slides
  memset(szResp, 0, 4);
  itoa(lSlideCount, szResp, 10); 
  PrepareResponse(ACK_COUNT, szResp, 4);

  return(1);
}


//--------------------------------------------------------------------------------
// Performs next animation or switches to next slide.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::NextSlide()
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {
    m_view.Next();
    return(1);  
  } else
    return(0); 
}


//--------------------------------------------------------------------------------
// Performs previous animation or switches to previous slide.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::PrevSlide()
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {    
    m_view.Previous();
    return(1);  
  } else
    return(0); 
}

//--------------------------------------------------------------------------------
// Goes to first slide.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::FirstSlide()
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {
    long index;
    
    index= m_view.GetCurrentShowPosition();
    m_view.First();

    // slide change?
    if (index != 1) CreatePreview(2);
    return(1);
  
  } else
    return(0); 
}


//--------------------------------------------------------------------------------
// Goes to last slide.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::LastSlide()
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {
    long index;
    
    index= m_view.GetCurrentShowPosition();
    m_view.Last();

    // slide change?
    if (index != m_view.GetCurrentShowPosition()) CreatePreview(1);
    return(1);
  
  } else
    return(0); 
}


//--------------------------------------------------------------------------------
// Goes to slide specified by argument "nr".
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
// -1: Invalid slide index.
int CPPTRCv2Dlg::GotoSlide(long nr)
{
  // we need an open slideshow
  if (OpenSlideShowExists()) {
    char szResp[4];
    long lSlideCount;
    
    Slides slides= m_pres.GetSlides();
    lSlideCount= slides.GetCount();
    slides.ReleaseDispatch();
    
    // range check
    if ((nr >= 1)&&(nr <= lSlideCount)) {
      m_view.GotoSlide(nr, 0);
      
      // ACK_NFO response
      // 4 bytes: index of current slide
      memset(szResp, 0, 4);
      itoa(m_view.GetCurrentShowPosition(), szResp, 10); 
      PrepareResponse(ACK_NFO, szResp, 4);
      return(1);
    
    } else 
      return(-1);
    
  } else 
    return(0);  
}


//--------------------------------------------------------------------------------
// Turns screen entirely black.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::BlackScreen()
{
  if (OpenSlideShowExists()) {
    long state= m_view.GetState();

    if (state == 1) m_view.SetState(3);  // 3: ppSlideShowBlackScreen 
    else m_view.SetState(1);  // 1: ppSlideShowRunning

    // ACK_NFO response
    Slides slides= m_pres.GetSlides();
    char resp[8];
    // 4 bytes: number of slides, 4 bytes: number of slides
    memset(&resp[0], 0, 8);
    itoa(slides.GetCount(), &resp[0], 10); 
    itoa(m_view.GetCurrentShowPosition(), &resp[4], 10);
    PrepareResponse(ACK_NFO, resp, 8);

    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Turns screen entirely white.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::WhiteScreen()
{
  if (OpenSlideShowExists()) {
    long state= m_view.GetState();

    if (state == 1) m_view.SetState(4);  // 4: ppSlideShowWhiteScreen
    else m_view.SetState(1);  // 1: ppSlideShowRunning

    // ACK_NFO response
    Slides slides= m_pres.GetSlides();
    char resp[8];
    // 4 bytes: number of slides, 4 bytes: number of slides
    memset(&resp[0], 0, 8);
    itoa(slides.GetCount(), &resp[0], 10); 
    itoa(m_view.GetCurrentShowPosition(), &resp[4], 10);
    PrepareResponse(ACK_NFO, resp, 8);
    
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Stops an auto-slideshow or starts it over. 
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::StopSlideShow()
{
  if (OpenSlideShowExists()) {
    long state= m_view.GetState();

    if (state == 2) m_view.SetState(1);  // 1: ppSlideShowRunning
    else m_view.SetState(2);  // 2: ppSlideShowPaused
  
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Clears all notes on screen. 
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::ClearNotes()
{
  if (OpenSlideShowExists()) {
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Switches to next hidden slide.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
// -1: No hidden slides in current slideshow.
int CPPTRCv2Dlg::GotoHidden()
{
  if (OpenSlideShowExists()) {
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Test slideshow with new auto-advance timings.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::TimeNew()
{
  if (OpenSlideShowExists()) {
    SlideShowSettings settings= m_pres.GetSlideShowSettings();
    m_view.Exit();
    settings.SetAdvanceMode(3);  // 3: ppSlideShowRehearseNewTimings
    RunSlideShow();
    settings.ReleaseDispatch();
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Test slideshow with old auto-advance timings.
// Possible returns codes are:
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::TimeOld()
{
  if (OpenSlideShowExists()) {
    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// Set advance mode to mouse-clicks.
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::MouseMode()
{
  if (OpenSlideShowExists()) {
    SlideShowSettings settings= m_pres.GetSlideShowSettings();
    settings.SetAdvanceMode(1);  // 1: ppSlideShowManualAdvance  

    return(1);
  } else
    return(0);
}


//--------------------------------------------------------------------------------
// If mouse-pointer is invisible and/or pen-style, make it an arrow.
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::ShowArrow()
{
  if (OpenSlideShowExists()) {
    if (m_view.GetPointerType() != 1)  // 1: ppSlideShowPointerArrow
      m_view.SetPointerType(1);

    return(1);
  } else 
    return(0);
}

//--------------------------------------------------------------------------------
// If mouse-pointer is invisible and/or arrow-style, make it a pen.
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::ShowPen()
{
  if (OpenSlideShowExists()) {
    if (m_view.GetPointerType() != 2)  // 2: ppSlideShowPointerPen
      m_view.SetPointerType(2);

    return(1);
  } else
    return(0);
}

//--------------------------------------------------------------------------------
// Make mouse-pointer invisible 
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::HidePointer()
{  
  if (OpenSlideShowExists()) {
    m_view.SetPointerType(3);  // 3: ppSlideShowPointerAlwaysHidden
    return(1);
  } else 
    return(0);
}




//--------------------------------------------------------------------------------
// Select first/next HyperLink in current slide by sending "TAB" key-event to PPT. 
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::NextHyperLink()
{   
  if (OpenSlideShowExists()) {  
    // prepare input data
    INPUT in[2];
    KEYBDINPUT ki[2];
    ki[0].wVk= VK_TAB;     
    ki[0].dwFlags= NULL;
    ki[1].wVk= VK_TAB;     
    ki[1].dwFlags= KEYEVENTF_KEYUP;
    in[0].type= INPUT_KEYBOARD;   
    in[0].ki= ki[0];
    in[1].type= INPUT_KEYBOARD;
    in[1].ki= ki[1];
    // send it
    SendInput(2, in, sizeof(INPUT));
    return(1);
  } else 
    return(0);
}


//--------------------------------------------------------------------------------
// Select first/next HyperLink in current slide by sending "SHIFT-TAB" key-event to PPT. 
//  1: Everything worked fine.
//  0: No open slide show.
int CPPTRCv2Dlg::LastHyperLink()
{
  if (OpenSlideShowExists()) {
    // prepare input data
    INPUT in[4];
    KEYBDINPUT ki[4];
    ki[0].wVk= VK_SHIFT;     
    ki[0].dwFlags= NULL;
    ki[1].wVk= VK_TAB;     
    ki[1].dwFlags= NULL;
    ki[2].wVk= VK_TAB;     
    ki[2].dwFlags= KEYEVENTF_KEYUP;
    ki[3].wVk= VK_SHIFT;     
    ki[3].dwFlags= KEYEVENTF_KEYUP;
    in[0].type= INPUT_KEYBOARD;   
    in[0].ki= ki[0];
    in[1].type= INPUT_KEYBOARD;
    in[1].ki= ki[1];
    in[2].type= INPUT_KEYBOARD;   
    in[2].ki= ki[2];
    in[3].type= INPUT_KEYBOARD;
    in[3].ki= ki[3];
    // send it
    SendInput(4, in, sizeof(INPUT));

    return(1);
  } else
    return(0);
}

//--------------------------------------------------------------------------------
// Makes context menu pop up (in current active window!).
//  1: Everything worked fine.
//  0: No open slide show was open.
int CPPTRCv2Dlg::ContextMenu()
{
  if (OpenSlideShowExists()) {
    HWND hWnd= ::GetForegroundWindow();
    ::PostMessage(hWnd, WM_CONTEXTMENU, (WPARAM)hWnd, 0x00FF00FF);
    return(1);
  } else  
    return(0);
}

//--------------------------------------------------------------------------------
// Activates currently selected mouseclick by sending "ENTER" key-event to PPT.
//  1: Everything worked fine.
//  0: No slide show was open.
int CPPTRCv2Dlg::HyperLinkMouseClick()
{
  if (OpenSlideShowExists()) {
    // prepare input data
    INPUT in[2];
    KEYBDINPUT ki[2];
    ki[0].wVk= VK_RETURN;
    ki[0].dwFlags= NULL;
    ki[1].wVk= VK_RETURN;  
    ki[1].dwFlags= KEYEVENTF_KEYUP;
    in[0].type= INPUT_KEYBOARD;   
    in[0].ki= ki[0];
    in[1].type= INPUT_KEYBOARD;
    in[1].ki= ki[1];
    // send it
    SendInput(2, in, sizeof(INPUT));
    return(1);
  } else  
    return(0);
}

//--------------------------------------------------------------------------------
BOOL CPPTRCv2Dlg::PrepareDriveList()
{
  char szBuffer[MAX_PATH]= {0};
  char szDrive[32]= {0};
  UINT uDrive=0;
  UINT uType;
  DWORD dwLogicalDrives= GetLogicalDrives();
  int iPos= 0;

  if(dwLogicalDrives) {
    for(uDrive=0; uDrive<32; uDrive++) {
      if (dwLogicalDrives & (1 << uDrive)) {
        
        wsprintf(szDrive, "%c:\\", uDrive + 'A');        
        uType= GetDriveType(szDrive);
        switch(uType) {
          case DRIVE_REMOVABLE:
            wsprintf(&szBuffer[iPos], "%c:%c\0", uDrive + 'A', FILE_MARK_FLOPPY);
            iPos+= 4;
            break;

          case DRIVE_CDROM:
            wsprintf(&szBuffer[iPos], "%c:%c\0", uDrive + 'A', FILE_MARK_CDROM);
            iPos+= 4;
            break;

          case DRIVE_FIXED:
            wsprintf(&szBuffer[iPos], "%c:%c\0", uDrive + 'A', FILE_MARK_HD);
            iPos+= 4;
            break;

          default:
            break;
        }
      }
    }
    iPos+= 2;
    PrepareResponse(ACK_FILEINFO, szBuffer, iPos);
    m_szCurrPath[0]= 1;
    return(TRUE);
  }
  PrepareResponse(ERR, "Can't retrieve file list!");
  return(FALSE);
}

//--------------------------------------------------------------------------------
BOOL CPPTRCv2Dlg::PrepareFileInfo(char *pszDir)
{
  WIN32_FIND_DATA w32fd;
  ULONG ulBufSize= 4096;
  char szSearchPath[MAX_PATH]= {0};
  char szFileName[MAX_PATH];
  char *szFileList= NULL;
  BOOL bOk= FALSE;
  ULONG ulCount= 0;

  // home directory requested?
  if (!strcmp(pszDir, "HOME")) {
    strcpy(m_szCurrPath, g_szHome);
  
  } else {
    // directory up?
    if (!strcmp(pszDir, "..")) {
      char *pszTemp= strrchr(m_szCurrPath, '\\');
      if (pszTemp) pszTemp[0]= 0;
      else m_szCurrPath[0]= 0;
    }  

    // refresh drive list?
    if ((!strcmp(pszDir, "."))&&(m_szCurrPath[0] == 1)) m_szCurrPath[0]= 0;

    // if there is no path selected, send available drives
    if (!m_szCurrPath[0]) return(PrepareDriveList());

    // drive was chosen?
    if (pszDir[1] == ':') {
      strcpy(m_szCurrPath, pszDir);  
  
    } else if ((strcmp(pszDir, "."))&&(strcmp(pszDir, ".."))) {
      strcat(m_szCurrPath, "\\");
      strcat(m_szCurrPath, pszDir);
    } 
  }

  // allocate memory for filelist
  szFileList= (char*)malloc(ulBufSize);

  // add wildcard
  strcpy(szSearchPath, m_szCurrPath);
  strcat(szSearchPath, "\\*.*");

  HANDLE hFile= FindFirstFile(szSearchPath, &w32fd);  
  if (hFile != INVALID_HANDLE_VALUE) {        
    do {
      if ((strcmp(w32fd.cFileName, ".."))&&(strcmp(w32fd.cFileName, "."))&&((w32fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != FILE_ATTRIBUTE_HIDDEN)) {
        strncpy(szFileName, szSearchPath, strlen(szSearchPath) - 3);                
        szFileName[strlen(szSearchPath) - 3]= 0;
        strcat(szFileName, w32fd.cFileName);
        // mark directories with '?' character
        if ((w32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) strcat(szFileName, "?");
      
        // create filelist
        if ((ulCount + strlen(szFileName) + 1) >= ulBufSize) {
          ulBufSize= ulBufSize * 2 + strlen(szFileName) + 1;
          char *strTempBuff= (char*)malloc(ulBufSize);
          memcpy(strTempBuff, szFileList, ulCount);
          free(szFileList);
          szFileList= (char*)malloc(ulBufSize);
          memcpy(szFileList, strTempBuff, ulCount);
          free(strTempBuff);
        }
        memcpy(&szFileList[ulCount], szFileName, strlen(szFileName) + 1);
        ulCount+= (strlen(szFileName) + 1);
      }
      bOk= FindNextFile(hFile, &w32fd);
    } while(bOk);
    memcpy(&szFileList[ulCount], "\0", 1);
    ulCount++;

    PrepareResponse(ACK_FILEINFO, szFileList, ulCount);
    free(szFileList);

    FindClose(hFile);
    return(TRUE);
  }
  
  PrepareResponse(ERR, "Can't retrieve file list!");
  return(FALSE);
}

//--------------------------------------------------------------------------------
// Called when a new TCP/IP message was received by the worker thread
int CPPTRCv2Dlg::OnReceive(char cmd, char *msg)
{   
  int ret;   
 
  // react depending on protocol command
  TRACE("switching: %c\n", cmd);
  switch(cmd) 
  {    
    // RUN POWERPOINT APPLICATION
    case CMD_RUNPPT:
      if (RunPPT() == -1) {
        PrepareResponse(ERR, "Could not start PPT!");
      } else 
        PrepareResponse(ACK_RUN, "");
      // send the already prepared response
      SendResponse();
      break;

    
    // OPEN SLIDESHOW
    case CMD_OPEN:
      if (!OpenSlideShow(msg))
        PrepareResponse(ERR, "File could not be found/opened!");
      // send the already prepared response
      SendResponse();
      break;


    // RETURN TO SLIDESHOW
    case CMD_RETURN:
      if (!ReturnToSlideShow())
        PrepareResponse(ERR, "File could not be found/opened!");
      break;


    // REQUEST FOR PREVIEW
    case CMD_PREVIEW:
      if (!OpenSlideShowExists())
        PrepareResponse(ERR, "No slideshow is open!");
      else
        CreatePreview(atoi(msg));
      // send the already prepared response
      SendResponse();
      break;
      
    // NEXT SLIDE
    case CMD_NEXT:
      if (!NextSlide())
        PrepareResponse(ERR, "No slideshow is open!");
      break;


    // PREVIOUS SLIDE
    case CMD_PREV:
      if (!PrevSlide())
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // FIRST SLIDE
    case CMD_FIRST:
      if (FirstSlide())
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // LAST SLIDE
    case CMD_LAST:
      if (LastSlide())
        PrepareResponse(ERR, "No slideshow is open!");
      break;


    // GOTO TO SLIDE NR 
    case CMD_GOTO:      
      ret= GotoSlide(atoi(msg));
      if (ret == 0) PrepareResponse(ERR, "No slideshow is open!");
      else if(ret == -1)  PrepareResponse(ERR, "Invalid slide index!");
      // send the already prepared response
      SendResponse();
      break;


    // BLACK SCREEN
    case CMD_BLACK:
      if (!BlackScreen())
        PrepareResponse(ERR, "No slideshow is open!");
      // send the already prepared response
      SendResponse();
      break;


    // WHITE SCREEN
    case CMD_WHITE:
      if (!WhiteScreen())
        PrepareResponse(ERR, "No slideshow is open!");
      // send the already prepared response
      SendResponse();
      break;

    
    // STOP PRESENTATION
    case CMD_STOP:
      StopSlideShow();
      break;


    // CLEAR SCREEN
    case CMD_CLEAR:
      ClearNotes();
      break;


    // SWITCH TO NEXT HIDDEN SLIDE
    case CMD_HIDDEN:
      GotoHidden();
      break;


    // AUTO-ADVANCE WITH NEW TIMINGS
    case CMD_TIMENEW:
      TimeNew();
      break;


    // AUTO-ADVANCE WITH OLD TIMINGS
    case CMD_TIMEOLD:
      TimeOld();
      break;

    
    // ADVANCE BY MOUSE_CLICKS
    case CMD_MOUSE:
      if (!MouseMode())
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // MOUSEPOINTER => ARROW
    case CMD_ARROW:
      if (!ShowArrow())
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // MOUSEPOINTER => PEN
    case CMD_PEN:
      if (!ShowPen())
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // MAKE MOUSEPOINTER INVISIBLE
    case CMD_HIDE:
      if (!HidePointer())
        PrepareResponse(ERR, "No slideshow is open!");
      break;


    // MAKE MOUSEPOINTER INVISIBLE IN 15 SEC
    case CMD_HIDEDELAY:
      if (OpenSlideShowExists())
        SetTimer(HIDE_TIMER, 15000, NULL);
      else
        PrepareResponse(ERR, "No slideshow is open!");
      break;

    
    // SHOW CONTEXTMENU
    case CMD_CMENU: 
      if (!ContextMenu())
        PrepareResponse(ERR, "No slideshow is open!");
      break;
                    

    // LAST/PREV HYPERLINK
    case CMD_PREVHL:
      ret= LastHyperLink();
      if (ret == 0) PrepareResponse(ERR, "No slideshow is open!");
      else if (ret == -1) PrepareResponse(ERR, "No Hyperlinks on slide!");
      else PrepareResponse(ACK_HL, "");
      break;
    

    // FIRST/NEXT HYPERLINK
    case CMD_NEXTHL:
      ret= NextHyperLink();
      if (ret == 0) PrepareResponse(ERR, "No slideshow is open!");
      else if (ret == -1) PrepareResponse(ERR, "No Hyperlinks on slide!");
      else PrepareResponse(ACK_HL, "");
      break;


    // MOUSECLICK-BEHAVIOUR OF HYPERLINK
    case CMD_CLICKHL:
      ret= HyperLinkMouseClick();
      if (ret == 0) PrepareResponse(ERR, "No slideshow is open!");
      else if (ret == -1) PrepareResponse(ERR, "Hyperlink is not valid any more!");
      else PrepareResponse(ACK_HL, "");
      break;
    
    
    // QUIT POWERPOINT 
    case CMD_CLOSE:
      ClosePPT();
      PrepareResponse(ACK_QUIT, "");
      // send the already prepared response
      SendResponse();
      break;   
      

    // FILE INFORMATION
    case CMD_FILEINFO:
      PrepareFileInfo(msg);
      // send the already prepared response
      SendResponse();
      break;

    
    default:
      // incorrect protocol command
      PrepareResponse(ERR, "Bad command!");
      // send the already prepared response
      SendResponse();
      break;
  }  
  return(0L);
}
